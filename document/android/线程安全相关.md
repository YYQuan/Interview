# 线程安全



线程安全问题是指 多个线程之间 对可变的 共享资源的操作的同步问题。
核心原因是由于多个cpu之间的 多级内存的数据缓存引起的。

所以说对于线程安全的问题 ，要点是两个。

1. 多线程之间 
2. 可变资源的数据同步



决定线程安全的要素有如下几个：

- 可变性 - 变量是可变的 才有可能出现线程安全问题
- 可见性-  各个cpu操作完了 之后是否会立即同步到主存中， 操作前会不会前去主存中同步
- 原子性-  一个操作是否是不可分割的
- 重排序 -  是否有由于cpu指令优化导致的

## synchoronize 

synchoronize 关键字主要处理的就是 同步性  ，同步前先去主存同步一下。
同步代码块 结束后 同步到主存当中。



## fatal & volatile

fatal 和volatile 都有禁止重排序的 语义。
避免由于cpu的重排序 导致多线程下有数据异常。

为啥dcl的单例模式一定要给单例变量加上volatile?
就是为了避免  重排序 导致的问题。

### 原子性操作  - CAS & ATOMIC

对于基本数据类型， 可以用

cas 指令  或者 各种的atomic 数据类型 来保证 操作的原子性。





# AtomicReference 和AtomicReferenceFieldUpdater 有何异同？



考察点，

- 原子操作
- 这两个类的用法和原理
- 对java内存占用的认识



## 原子操作

这两个都是对非基本数据类型来做原子操作的。



## 两个类的区别

### 基本用法

#### AtomicReference的基本用法

![image-20210713163801252](https://i.loli.net/2021/07/13/RIqcfBHVO95XDEb.png)

本质上就是通过volatile 和 CAS 指令来完成的。



#### AtomicReferenceFieldUpdater的基本用法

![image-20210713164234247](https://i.loli.net/2021/07/13/W8SYQBzga7KjLDC.png)

明显这个AtomicRegerenceFieldUpdater  更难用。
用法上 类似反射。
先用AtomicReferenceFieldUpdater根据属性名称来绑定上属性。
然后用类似反射的方式来调用。

### AR & ARFU 对比

![image-20210713171316534](https://i.loli.net/2021/07/13/FxMyblSZdt4HnwP.png)

从上图可以看出， AtomicRegerenceValueHolder也是通过AtomicaReference来完成 原子操作的。
那为啥还要多包一层呢？
原因就是atomicRegerence一个引用就需要多占用4个字节（一个指针）， 如果说有很多atomicReference的话 ，那么就会有大量的内存浪费。
所以设计了atomicReferenceFieldUpdater,内部只维护了一个AtomicReference来完成原子操作。
通过atomicReferenceFieldUpdater 就算绑定在多变量，也只有用到16个字节。

总体 说  atomicReference和AtomicReferenceFieldUpdater的核心区别就是 AtomicReferenceFieldUpdater能节约内存，减少内存浪费。



## AtomicRefereneFieldUpdater的应用

BufferedInputStream中有使用了ARFU
bufferedInputStream就是用过ARFU 来更新buffer的

![image-20210713173703153](https://i.loli.net/2021/07/13/7UryhmOBk8MqR1D.png)

BufferedInputStream的使用频率是非常高的，如果用atomicReference的话， 那就会有大量的内存浪费。





# 优雅的写异步



- java  furtrue 
- android 远程  asyncTask  
- rxjava  ： 内部其实就是 线程池 加回调来完成的。
  要注意 异常的处理
- kotlin ： 本质就是一个回调

kotlin协程的异步 写法上和同步基本一模一样。
kotlin的协程和rxjava对比有一个 优势， 协程对于异常的处理，可以直接 try catch。

