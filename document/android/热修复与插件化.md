# 热修复与插件化



讲热修复和插件化要从 java的class 和android的dex文件 开始入手。

现在说说 Class文件 和dex文件的接口



## Class文件与Dex文件



先创建一个helloworld 的java文件。

![image-20210429164712037](https://i.loli.net/2021/04/29/NSp2sa4KzGJ58Oh.png)

用javac命令来  得到class 文件。

得到class文件后， 用 010Editor来分析 class文件。

下图就是 java文件生成的class的解析的内容。

![image-20210429164638184](https://i.loli.net/2021/04/29/eLBIhY1Tf3NsHSo.png)

### CLASS里的字段信息

从这上面分析 可以得到重要的有如下几个 类目：

CONSTANT_CLASS_INFO
CONSTANT_MethodRef
CONSTANT_FieldRef
CONSTANT_String
CONSTANT_NameAndType

CONSTANT_Utf8: 指针的索引  其他字段里的指针 指向的位置。

上面这些都是意义很明确的字段.
而且都是指针    另外基本都是 两, 三个字段来表示的。  

字段分两种类型：一个表示类型（占一个字节） 一个是信息（占两个字节）。
信息包括  名称的指针哇， 类型的指针哇 ，描述的指针哇。

**注意注意注意**： 索引 是从0 开始计数的。但是 指针里的值是从1 开始的计数的。
所以 指针里的值  是1 的话 ，那么 对应的是索引0 。

这些个字段  主要就是class info 和method ，其他的都是比较直白简单的字段。

#### CONSTANT_CLASS_INFO

这个字段表示的是 内中的内容的信息。
我的理解就是代码。

先看看结构

![image-20210506101146421](https://i.loli.net/2021/05/06/96J1RQXf84YsOSK.png)

这个的class 的名称信息的索引是34  接着看看索引是   34的引用

![image-20210506101050581](https://i.loli.net/2021/05/06/TG2Wi9EfCkFYgAd.png)



也就是一个类把关联的类通过class_info都可以找得到。



#### CONSTANT_MethodRef

MethodRef 需要结合class  文件中 函数的结构体来判断。

以刚才的main函数为例子。

从下图分析  函数结构体里 就有 函数名的索引 和 函数参数的索引
但是没有返回值的索引。
所以也就说明了为啥函数的重载 用返回值是无法区别的。

![image-20210506101358727](https://i.loli.net/2021/05/06/HlAsOCD8ehmPxzj.png)

分析一下字段。
这个  attributes_count  看名字像是 下面的attributes_info_attributes字段的数量。
函数中的具体代码的展现 需要看看attributes_info_attributes

##### attributes_info_attributes

![image-20210506104523112](https://i.loli.net/2021/05/06/ObloMtBrEP9jeia.png)

根据上图的线索  跟踪到了函数的结构体里有每一个行的信息。
这个信息是根据一个struct code 的数组来的。
这家来就看下图这部分。

![image-20210506110456706](https://i.loli.net/2021/05/06/lSp28P9ovBJNxas.png)

以Hello world 为例子


![image-20210506110703341](https://i.loli.net/2021/05/06/NRe86IQz15mZTqj.png)

根据索引 找到  String  : hello world ；

根据 operator  编码 确定 要执行的 操作是ldc操作。
ldc 是jvm的指令。
ldc做的事情就是 从运行时常量池将对象压入操作数栈中。
也就是这个操作就是把 hello world给压入 操作数的栈中的了。

其他语句也是差不多是这个逻辑。
要注意的是 看起来指令 还想都是想讲目标参数 入栈， 然后再执行函数，让函数在参数栈中去取参数。

所以 函数结构体里面就是通过 操作符 和 索引指向的值 来指明操作的。







#### 注解信息字段

现在有个问题。
注解的信息是怎么保存在 class文件里的呢？
在class的属性标签下 专门有个属性名称为 runtimeVisibleAnnotations的字段。
 注解就保存在这里。

![image-20210506113158728](https://i.loli.net/2021/05/06/d58xzcBqGRsZlLF.png)



#### 泛型

那有泛型的是怎么样的？

创建一个 带泛型的类 Union

![image-20210506114502893](https://i.loli.net/2021/05/06/Nd5pfgrz9IxMyVO.png)

然后在Main.main中调用Union.test

![image-20210506114516047](https://i.loli.net/2021/05/06/FRLXi4bdSmlIOAj.png)看看两个类的class文件。

先看有泛型的Union

![image-20210506114715089](https://i.loli.net/2021/05/06/b61fyu5qXRLTokV.png)

带泛型的类 还会多一个 属性  signature

根据下图的对比。
泛型信息是由存下来的。
不过全部的泛型  是用一个字符串  存下来的。并不是一个一个的泛型类型存的。

![image-20210506121613883](https://i.loli.net/2021/05/06/5XQWOoHLyVYlR6i.png)



小结： 
每一个类都有自己的class 文件 都有文件头  ，常量池。
对于不同类中的相同的常量 每个class 文件中都有属于自己的那份。 所以大量类的情况下， 是有大量的重复的字段的。

 这样class文件的 研究先到这里了。

### DEX文件

dex 文件是由class文件演化而来的。
主要就是为了解决 在类很多的时候，class文件有大量的验证信息 ，每个class文件都有自己独立的常量池（很可能会有大量重复的常量存在）， io的操作次数也会比较多。
dex文件等于是把全部class文件都整合进来，这时只需要一个大的IO操作即可。 而class文件的话， 要加载一次新的class就要去进行一次IO操作。

![image-20210506140721271](https://i.loli.net/2021/05/06/9OYc154lxDkVwvs.png)

android 虚拟机加载dex的时候  就把全部要用到的类的信息都加载进去了。

全部都是索引  没有 class那种类属性的字段。
那怎么把类的属性获取到呢？
比如说 类的泛型信息 ，类的注解信息这些是怎么拿

以SimpleArrayMap为例子，  看 class的索引。
里面有

![image-20210507152017462](https://i.loli.net/2021/05/07/fPkHVw4FxmvESbR.png)

类名的字符串里 带着泛型个数信息
![image-20210507152142526](https://i.loli.net/2021/05/07/nWxQyapUgVOF8km.png)

所以 dex的类的信息都是有的。

现在已经知道了，  class文件和 dex文件的大致情况了。

接着分析虚拟机怎么加载dex中的类。



## android虚拟机的类的加载



虚拟机用双亲委派的策略进行加载类。

### 双亲委派

java中

![image-20201207101425223](https://i.loli.net/2020/12/07/ysprbSBX6UtYVoG.png)

![img](https://img.mukewang.com/wiki/5f1f8a6309f6733603840620.jpg)

### 双亲委派的作用

![image-20201207101558504](https://i.loli.net/2020/12/07/4Pi3dIkoc2b6fQy.png)



android中的类加载继承了java的类加载的方式。
但是类加载器的类有所不同。

android中主要的类加载器

- PathClassLoader
- DexClassLoader
- BaseDexClassLoader

其实PathClassLoader和DexClassLoader都没有做啥实现， 主要的就是把BaseDexClass的构造参数暴露出来。
，但其实也没用这些参数。这么做的目的估计是为了向前兼容。
所以实际上都是BaseDexClassLoader在处理。

### 类加载

#### BaseDexClassLoader

![image-20201207102312917](https://i.loli.net/2020/12/07/rDxSigmce5TuO6p.png)

![image-20201207102352054](https://i.loli.net/2020/12/07/DARTVvX8k1ewjtf.png)

这几个参数的意义
1.dexPath   :要加载的dex文件的路径
2.optimizedDirectory :加载出来的dex文件的 缓存  存放在路径
3.librarySearchPath要加载的c++链接库的路径

由于AS中 看不到BaseDexClassLoader的实现， 先用网上的来分析。

BaseDexClassLoader

构造函数

```java
public class BaseDexClassLoader extends ClassLoader {
    ...
    public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent){
        super(parent);
        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);
    }
    ...
}	
```

获取class

```java
private final DexPathList pathList;

@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {
    List<Throwable> suppressedExceptions = new ArrayList<Throwable>();
    // 实质是通过pathList的对象findClass()方法来获取class
    Class c = pathList.findClass(name, suppressedExceptions);
    if (c == null) {
        ClassNotFoundException cnfe = new ClassNotFoundException("Didn't find class \"" + name + "\" on path: " + pathList);
        for (Throwable t : suppressedExceptions) {
            cnfe.addSuppressed(t);
        }
        throw cnfe;
    }
    return c;
}
```

从上可以看出classLoader加载的是通过dexPathList来查找的。

接下来看看DexPathList

### DexPathList

```java

class DexPathList{
  public DexPathList(ClassLoader definingContext, String dexPath,String librarySearchPath, File optimizedDirectory, boolean isTrusted) {
     //dexPath="/data/data/**/classes.dex:/data/data/**/class1.dex/data/data/**/class2.dex"
      //根据传递的dexpath加载出所有dex文件路径
      this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions, definingContext, isTrusted);
      //加载APP的动态库
      this.nativeLibraryDirectories = splitPaths(librarySearchPath, false); 
      //加载系统的动态库
      this.systemNativeLibraryDirectories =splitPaths(System.getProperty("java.library.path"), true);
      ......
  }
    
    private static Element[] makeDexElements(List<File> files,  optimizedDirectory, List<IOException> suppressedExceptions, ClassLoader loader, boolean isTrusted) {
      Element[] elements = new Element[files.size()];
      int elementsPos = 0;
      for (File file : files) {
          if (file.isDirectory()) { 
              elements[elementsPos++] = new Element(file);
          } else if (file.isFile()) {
              String name = file.getName();
              DexFile dex = null;
              //如果文件路径以.dex结尾，则直接加载文件内容
              if (name.endsWith(DEX_SUFFIX)) {
                  try {
                      dex = loadDexFile(file, optimizedDirectory, loader, elements);//  加载dex文件到内存当中
                      if (dex != null) {
                          elements[elementsPos++] = new Element(dex, null);//用一个数组来维护dexFile对象
                      }
                  } catch (IOException suppressed) {
                      System.logE("Unable to load dex file: " + file, suppressed);
                      suppressedExceptions.add(suppressed);
                 }
              } else {
                  try {
                     //如果是jar,zip等文件类型，则需要先
                      dex = loadDexFile(file, optimizedDirectory, loader, elements);//  加载dex文件到内存当中
                  } catch (IOException suppressed) {
                      suppressedExceptions.add(suppressed);
                  }

                   if (dex == null) {
                      elements[elementsPos++] = new Element(file);
                  } else {
                      elements[elementsPos++] = new Element(dex, file);//用一个数组来维护dexFile对象
                  }
              }
              if (dex != null && isTrusted) {
                dex.setTrusted();
              }
          } else {
              System.logW("ClassLoader referenced unknown path: " + file);
          }
      }
      if (elementsPos != elements.length) {
          elements = Arrays.copyOf(elements, elementsPos);
      }
      return elements;
    }
    //从这里可以看出 optimizedDirectory 不同,  DexFile对象构造方式不同，我们继续看看 optimizedDirectory 在 DexFile 中的作用：
    private static DexFile loadDexFile(File file, File optimizedDirectory)
        throws IOException {
    if (optimizedDirectory == null) {
        return new DexFile(file);
    } else {
        String optimizedPath = optimizedPathFor(file, optimizedDirectory);
        return DexFile.loadDex(file.getPath(), optimizedPath, 0);
      }
   }  
    
    public Class findClass(String name, List<Throwable> suppressed) {
    for (Element element : dexElements) {
        // 遍历出一个dex文件
        DexFile dex = element.dexFile;

        if (dex != null) {
            // 在dex文件中查找类名与name相同的类
            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
    }
    if (dexElementsSuppressedExceptions != null) {
        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
    }
    return null;
}
}

```



DexPathList在构造是就把dex文件都加载到内存当中。
DexPathList加载的是dex文件 ，核心就是DexPathList 用了一个数组去维护dexFile对象。
这个dexFile对象就是 dex加载到内存后的实例。
然后加载类的时候就通过dexPathList的find 函数去 数组当中去找  ，找到一个就退出。
所以说在有多个dex拥有同一个类的情况下，只有在dexpathlist 数组前部的dex中的该类会被加载到内存当中。
这个就是热修复的基础。

想要替换掉哪个类， 就把dexPathList维护的 dexfile  给反射替换掉。 把 有待替换的dex 放在数组的最后， 补丁dex放在前面。这样 要加载类的时候就会先加载 补丁包里的类。



### ClassLoader加载的流程 

dalvik 启动   -》 DexPathList 加载全部dex，把加载的dexFile 用 数组维护  -》 需要加载某一个类 
-》 classLoader 去find -》  classLoader 里通过DexPathList去找   
-》 DexPathList从  dexFile的数组里按顺序找 找到一个就返回。

### 加载Class

前面已经分析到 Dex文件里是有类的索引的，dexFile加载类和找类  其实就是在dex文件中找类的索引。看有没有同名的。

加载Class   从应用层上看实际上就做了三件事情：

- 把dex文件中  通过索引找到的class信息 全部加载到方法区
- 生成一个class类对象 放入堆中 把 class类对象和 方法区关联起来
- 进行类初始化  比如 静态变量的赋值



#### 类加载的步骤

类的加载分为三步：

- 装载 ： 也就是把 dex中的class的信息加载出来 以及在堆中生成一个类对象的实例（Class 对象）关联类和静态区。
- 链接： 主要就是做些验证工作（保证类的正确性和语义的正确性）和优化工作（把一些字符引用直接替换为直接的指针引用），以及给静态变量分配内存
- 初始化：调用Class.forName, 给静态变量进行赋值，等等。(
  实际上 静态变量 的初始化赋值就有由 Class.forName来调起的)



![img](https://img.mukewang.com/wiki/5f1f8aa6092a3eaf53241882.jpg)



![image-20201207114520368](https://i.loli.net/2020/12/07/TpwUgdr7Vcmz8no.png)

![image-20201207114533094](https://i.loli.net/2020/12/07/tylSid8Kabx7r3M.png)



![image-20201207114541851](https://i.loli.net/2020/12/07/hT57ZLAPb1sRgGt.png)



```java
class MainActivity{
   //在准备阶段他得值为默认值0，初始化阶段才会被赋值为3.
   
   //因为把value赋值为3的putlic static语句在编译后的指令是在类构造器<clinit>（）方法之中被调用的，所以把value赋值为3的动作将在初始化阶段才会执行。
   static int value = 3；//0x0001
   
   int value2=3;//随着对象实例化的时候，才会被赋值
  
  static void test(){
      value2 = 100;//静态方法为什么不能访问非静态变量？
  }
}

```

有了上面的分析：
尝试回答下面的几个问题。

#### QA

##### **静态方法里为什么不能访问实例变量？**

因为静态方法在 类加载的加载阶段 就和静态变量这些一块放进 方法区了， 是全局唯一的。
而此时非静态的实例变量 还不存在，静态方法自然无法访问。
另外，实例变量是随实例而生成的， 不是唯一的。 静态方法访问的话， 也不知道该去访问哪一个。

##### Class.forName 和 ClassLoader.loadClass的区别

Class.forName   会触发类的静态变量的赋值.
ClassLoader.loadClass 并不会 触发类加载过程中的第三步  初始化这步。
实际上 Class.forName 内部就用通过ClassLoader.loadClass来处理的。

![image-20201207143148408](https://i.loli.net/2020/12/07/MhIRA2zEiYoNw3H.png)



##### 类的初始化的问题分析- 为啥成员变量会在静态变量之前被赋值？

这和类加载时 初始化的执行相关。

上述这个现象 经常会在 饿汉式的单例当中发现。
![image-20201207144142587](https://i.loli.net/2020/12/07/jATKUJtEasX6Fnv.png)

饿汉式中发现有成员变量在静态变量前被赋值是由于在类加载的初始化阶段， 先把单例的实例的构造函数给执行了，这个时候就把成员变量先给赋值了。
然后 后面的静态变量才被赋值。
这就有了成员变量比静态变量更早初始化的问题。

要避免这个问题 可以使用静态内部类的方式来实现单例。
调用到SIngletonInstance.INSTANCE 的时候 才会去执行外部类的构造函数， 此时外部类的静态代码都已经全部执行完了。
所以就能确保 静态变量的初始化在 成员变量之前赋值。

## 热修复

主流方案：

![image-20201207151127298](https://i.loli.net/2020/12/07/6zeQg2qhcCyrTSA.png)

AndroidStudio的INSTANCE Run的实现原理是 类加载方案。

从底层替换的方案 andFix已经废弃，Sophix 收费。而且也比较复杂。

这里主要研究类加载方案的代表Tinker.



### 动态加载dex方案

![img](https://img.mukewang.com/wiki/5f1f8c3d095e254584503246.jpg)

学习类加载的时候就已经知道了 ClassLoader中的DexPathList中维护了一个dexFile的数组。 动态修复dex的方案的原理就是把要替换的dexFile插入到DexPathList的数组的头部。让修复好的class代替要修复的class.



- 找到ClassLoader.DexPathList 
- 执行DexPathList.makeDexElements方法生成包含dex的数组
- 向dexPathList合并新加载进来的dex数组

### Tinker工作原理简述

- 使用bsdiff对新旧apk做差分异，得到差量化产物patch.apk。
  bsdiff是基于二进制的差异比较得到的包，体积会很小。

- 把新得到的差异包和目标版本进行全量合并，得到新的apk文件
  class文件 、so文件 -》  tinker-NClass.apk
  res文件  -》 resource.apk

  为啥class和res要分成两个包呢？
  是因为 class和res 类和资源的热修复方式不一样。

- 类更新 apk 进行dex插队来修复
  资源更新 用反射去替换AssetManager来完成修复

这里要强调， 下发的只是差分包，全量合并是在本地执行的。