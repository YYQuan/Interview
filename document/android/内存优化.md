# 内存优化



# 如何避免OOM

- 使用合适的数据结构

  ![image-20210714150039752](https://i.loli.net/2021/07/14/whCoNjXU4MA3xp7.png)

  

  SparseArray    和ArrayMap的区别，避免装箱和拆箱。

  基本数据类型 对应的类 为啥要有装箱和拆箱。
  因为泛型都是引用， 引用的内存长度是一致的，  而基本数据类型是不一致， 装箱和拆箱可以理解为  统一内存长度的过程。

- 避免使用枚举
  不过枚举现在好像会被编译优化成整形了
  android  引入了 intdef注解 来约束 整形的范围

  ![image-20210714150953068](https://i.loli.net/2021/07/14/XM2oIvSzHaQBuhf.png)

- Bitmap

  - 用epic在debug的时候插桩监控 view和 bitmap宽高是否差异太大
  - 尽量不使用帧动画， 而用代码来实现
  - 内存中尽量只加载 缩略图 ，不加载原图。

- 谨慎使用多进程

  - fork出来的 子进程 会继承父进程全部资源，子进程里面就算只运行很轻量级的任务， 但是也是持有着大量重副进程中过来的资源的

- 使用ndk
  ndk没有专门的使用限制。避免java的堆内存的限制。

- 复用高频率使用的对象

# 如何对图片进行缓存

内存/磁盘/网络





android 系统中 提供了 LruCache类。
不过要注意   
原生包提供的Lrucache 每次移除的是最近使用的那个，
而support包下的  移除的才是最久使用的那个



LRU 算法 （最近最少策略。）

glide的缓存

glide  分了三级缓存 。
glide在磁盘中缓存了 原图以及目标大小的图片，  内存中只缓存了目标大小的图片。
对于同一个图片的不同尺寸  glide在磁盘和内存中都有缓存。



# 如何计算图片占用内存的大小？

目的： 在加载之前就预先算出要占多大的内存。 而不是加载出bitmap对象之后， 再去获取。

- 内存大小和文件大小 是有差异的 ，文件是有可能被压缩过的。



## Density

像素密度

![image-20210714155920526](https://i.loli.net/2021/07/14/np2xQ4yRmzLCXt7.png)



系统绘图的时候加了一层抽象， 

先直接按照 view的数值 在抽象层中绘出，然后再根据dpi来进行等比的放大到真正显像的设备中去。



## bitmap的所占内存



![image-20210714160433159](https://i.loli.net/2021/07/14/vtcdZ41OFMI2G8P.png)

实际占内存 有时和  应该占多大 有区别呢？

因为bitmap的对象创建是 是有参数配置的， 如果说参数配置的 开辟的空间大于   应该占多大内存的话， 那么  实际占的内存就会以开辟出空间为准。而不是以应该占多大为准。



## 预先计算图片所需大小

### Assets中的图片

#### png

![image-20210714162407666](https://i.loli.net/2021/07/14/Y2CyMF8vRlhAuZe.png)

对于 png 格式来说  是由透明通道的

计算方式  

 所占内存（Byte） =     宽（px）  * 高(px)  * 4   (  8888 格式下 每个像素 需要四个字节) 



#### jpg

对于jpg格式来说 是没有 透明通道的。
 8888格式是有浪费的。

所以可以指定成更加省内存的565格式来处理。


565格式的话， 一个像素就只占2个字节
如果是指定成8888的话 ，那一个像素还是 4个字节。

![image-20210714162924852](https://i.loli.net/2021/07/14/F59hasCEUc3AKWw.png)

对于565

计算方式  

 所占内存（Byte） =     宽（px）  * 高(px)  * 2  ( 565 格式下 每个像素 需要2个字节) 

```
tips:png的图片也可以用565  565 的话 就忽略了透明通道了。
```



### Drable 中的图片

在手机中，同样一个图片 ，从assets 移动到 drawable-hdpi后  获取到的图片的宽高会发生改变。

变化的规则是
根据目录所表示的dpi  和当前屏幕大小来算出来的

改动后的值  =    源值 /（目录所表示的dpi） *屏幕大小

![image-20210714164618064](https://i.loli.net/2021/07/14/Kcqny2WGO5dSVL3.png)

drawable-nodpi 目录下的资源是不做缩放的

### 小结

要想预先计算 图片所占内存有两个因素

- 图片尺寸
- 图片加载格式 

图片加载格式 一般只有 8888 和 565 

图片的尺寸的话，和图片所在的路径有关系。
如果是在drawble的下，就会根据 目录所在的dpi和 屏幕的dpi进行缩放。 也就是说 文件本身的宽高 和代码里读出来的 是不一定一致的。



## 图片内存优化

- 和文件存储格式无关 
- 采样率   大图变小图
- 通过矩阵计算来放大图片   小图变大图
  存的时候都是小图， 绘制的时候 才是大图，从而减少了内存消耗
- 用 565加载 不关心透明度的图片
- 使用9-patch图片   ： 对于拉伸的部分直接复制 ，不需要保存到内存中 从而达到减少内存的目的。



## 索引模式

在android 26 之前能使用。
本质就是 本来 一个像素需要 用 4 个字节（888） 、2个字节（565）来表示。

但是索引模式下，先建立一个颜色的数组的索引表， 然后像素只用一个字节来表示， 像素的具体的值 通过 该字节和 索引表来得到。

索引模式的图片得到的bitmap对象不能用于canvas的创建的。
索引模式用起来很麻烦， 来一个图片就的去拓展一个像素的索引表。

















