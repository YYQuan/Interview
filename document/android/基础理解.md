## Application的理解



答题脉络

- application的作用
- application的类继承关系
- application的初始化原理



### 作用

- 提供横跨进程生命周期的上下文
- 给进程进行初始化的入口
- 保存应用进程的全局变量，提供感知进程生命周期的能力

#### 为啥能有以上作用？

取决于application的特点， 

1. 生的早
2. 活得长

application 是早于四大组件创建的。
application是跟随进程的，不是跟随应用的 应用有几个进程就会有几个application 



### Application的继承关系

继承了context接口， 但是实际上context能力是由外部传入的。
context的能力其实就是和系统服务沟通的能力。
传入的context的重要参数就是 ActivityThread中的IApplciationThread，
这个binder接口告知了 ams该回调给谁。



### application的生命周期

application的创建是在zygote force出进程后
就会去回调ams的attachApplication 并且传入一个binder对象。（实际上，这个binder对象就是和本进程关联起来了，ams的回调就通过这个binder对象来处理）
如下图

![image-20210810220546496](https://i.loli.net/2021/08/10/mcUPli6bsGZYVLy.png)



然后ams 就会通过用户进程传入binder去调用 bindApplication
![image-20210810220842030](https://i.loli.net/2021/08/10/YNQs6W3xZRO41yL.png)


下面就会回到用户进程来处理了

这段就是application的创建。
创建好之后 就会调用 application的oncreate.

![image-20210810205534377](https://i.loli.net/2021/08/10/e2GXg9oRarBLlhT.png)


上面也能看出 application的创建是需要传入 context的。
application的context能力也是通过外部传入的这个context来得到的。
看看这个context是怎么new出来的
下面这里可以看到 context是用activityThread来new出来。 
ActivityThread是进程的入口， 我感觉context能和系统服务进行binder通讯就是 通过activityThread来实现的

![image-20210810205816813](https://i.loli.net/2021/08/10/7kHK9Ssf4ATeqUC.png)





这里可以看出来ams的start要有这个binder接口才行。
要不ams 不知道要回到那个进程去处理。
所以 context的和系统服务的交互，本不依赖于activityThread ，
也就是通知给系统服务 是随便哪里都能做的到的，但是得让ams知道该回给谁  要给谁处理。
这就的通过ActivityThread维护的iApplicationThread 成员来完成了。
ActivityThread是 用户进程的入口。

![image-20210810211346758](https://i.loli.net/2021/08/10/4oNkjRE2crUla5t.png)



回到application的理解中来。

attach了context 之后 就直接在本进程用去调起applicaiton的onCreate函数了。

![image-20210810222149568](https://i.loli.net/2021/08/10/oWyBhLYOqvAaHm8.png)

前面已经分析到了 appliation的context的能力 是由外部传入的得到的。
其中的重点就是传入的ActivityThread 中的IApplicationThread的 binder接口， 能告知ams该回调给谁。

#### 小结application的启动

进程启动后， ActivityThread调用了ams的attach 并且传入本进程的ibinder接口，
ams通过传入的ibinder回调bindApplciation。
接下来就回到了 引用进程中， 应用进程通过handler 从binder线程切换到主线程中，然后执行 applicaiton的初始化。



#### 小结下 application的初始化



先用ActivityThread对象构建出context,
然后通过反射去创建出application
接着attach context
再去执行oncreate

所以不能再application的构造函数中去 使用context 因为这个时候 还没attach上baseContext

#### 注意不要在Application的生命周期函数中执行耗时函数

注意 不要在application的生命周期函数中执行耗时操作。
因为AMS的binder接口是非阻塞（oneway）的，不会影响到后序应用进程的相关操作。
所以AMS是会一下执行很多个用户进程的回调的。
这些回调都需要在用户进程中通过handler去回到进程主线程中去执行，
如果application的生命周期，那么不会是在ams中阻塞，而是会在用户进程的主线程handler当中阻塞住其他的application的初始化， 比如四大组件的初始化。

#### application的一个坑

在Application中使用静态变量容易产生的一个bug

Application的静态变量 再被系统回收之后的重建的话，会回到初始状态。这个时候就会有bug.
比如MainActivity设置了application的一个静态变量。
然后跳转到TestActivity,
接着把应用置到后台，
如果这个时候系统由于内存不足等原因的回收了进程。
再重新唤起应用，这个时候系统就会去重建application和testactivity.
但是此时的application的静态变量就不是之前的值了，而是回到了默认值。
怎么解决这个问题？
用activity的onSaveInstance /onRestoryInstance 来恢复数据。

![image-20210810215418950](https://i.loli.net/2021/08/10/nYuSJXfN83Kmo9s.png)



## Context是什么



[参考](https://blog.csdn.net/lmj623565791/article/details/40481055)



思路

- context的作用
- context的初始化流程
- 不同组件提供的context之间的区别

### 作用

context 的作用其实就两个

- 和系统服务通讯
- 调用系统和自己的资源

这个可以从 context的构造函数中就可以判断出来。


![image-20210811165746475](https://i.loli.net/2021/08/11/ACsEce5IixngbWG.png)

创建context 的参数有两个， 一个是ActivityThread, 一个是安装包信息。
也就是对应着 和系统服务通讯的能力 和 访问资源的能力。











### 初始化流程

context 一共有三种

- application 
- activity
- service

这三个组件虽然都是继承了context ，但是实际上其作用的是内部的mBaseContext变量。
这个变量是通过 attachBaseContext 传入的。

这三种context的都是先反射构建出了对象之后 ，接着attach base context, 再去执行onCreate的。

所以在构造函数中 这些组件都还没有 context的能力的。得等attach了之后才有。

```tips
为啥要设计出明明继承了context 但是还用外部传入的context，这种静态代理的模式呢？

这样带来的好处是提供了 反射替换的入口。
这样可以有入口去做一下额外的处理。有些插件的功能就是这么实现的。
```



### 区别

前面说到了 context 有三种。

application，activity ,service
他们之间有什么区别呢？

从类继承关系入手

![image-20210811171151968](https://i.loli.net/2021/08/11/E7jNm3JVipR1ATc.png)

![image-20210811171134780](https://i.loli.net/2021/08/11/pQwkaB3SyYdshr6.png)

![image-20210811171248426](https://i.loli.net/2021/08/11/SaBXpKmLuy5RHW2.png)



从上图可知 ，activity是继承至ContextThemeWrapper的。
而application和service都是继承至ContextWrapper。

从名称上都能看出 activity多了对主题的管理。

从功能上也能知道。
因为activity还承载了界面显示的任务，所以和application和service相比，肯定要多些东西。

这也说明了为啥dialog的context一定要activity的， 不能用application或者service的。
因为application 和service的context根本就没有显示的能力。



```tips
另外两个组件 contentProvider和BoardCast 里都管理着 context ，但是这两个context本身都没有集成context,并且他们的context都是从外部传入的。

contentProvider 里的就是application
boardcast里的 如果是静态广播那么就是 application ,动态广播的话就是注册的时候传入的那个context.
```



### 问题：

#### 应用里面有多少个Context 不同context 有什么区别？


context 有三种 application ,activity ,servie.
应用里的context的数量就是 这三个组件的数量的和。

这三个context 除了生命周期的长度不同之外， 只有activity有渲染界面的能力，其他方面区别不大。



#### Activity的this和getBaseContext的区别

activity的this 返回的是自己，
getBaseContext 返回的是attach上的mBaseContext;
从context的能力上来说 是一样的。
但是对象不是同一个。

#### getApplication和getApplicationContext的区别

getApplication不是Context的函数， 是activity和service特有的。
getApplicationContext才是context的函数。

#### 应用组件的构造函数 ，onCreate ，attachBaseContext的调用顺序

都是先反射调用构造函数 ，然后 attach 接着在执行onCreate的。



## Binder的理解









分析维度

- binder是干嘛的？
- binder的存在的意义
- binder的原理



### binder是干嘛的


binder是android 特有的 ipc通讯方式。
android系统里，除了Zygote和SystemService之间用的是socket，其他的ipc通讯都用的是binder

### binder存在的意义

binder是android 特有的跨进程通讯方式，
对比起ilinux的ipc通讯。

他有如下的优势：
由内核进行统一管理， 比socket安全。
只进行一次用户空间到内核空间的拷贝，比socket和管道的方式快。
客户端和服务端独立内存空间，比共享内存的方式简单。因为不需要处理两个进程同时操作同一块内存的场景。

### binder的原理

核心 客户端 和服务端 通过binder驱动在serviceManager中找到给分配的内核空间， 在内核空间中通过内存映射 来减少了一个内核空间到用户空间的数据拷贝。

数据的流程 是通过binder驱动来完成的。
但是进程的内核空间的内存分配和binder对象的管理是通过ServiceManager来完成的。

![image-20210812123532581](https://i.loli.net/2021/08/12/BvMgfAt91aOpzbr.png)

#### 关联方

以系统服务的 binder的通讯为例子，  一共有四方参与。

- client
- server
- ServiceManager（只有系统服务的binder才能注册到 serviceManager）
- binder驱动

#### ServiceManager的初始化

ServiceManager 启动之后 就会启动binder线程， 然后和binder驱动绑定。 接着就启动了binder的loop循环，等待binder消息。

#### 系统服务的注册

接着系统服务就可以往ServiceManager注册。
注册ServiceManager 也要有如下几步：

- 启动自己进程的binder线程
- 通过进程的状态对象 找到serviceManager的binder对象
- 通过serviceManager的binder对象调用addService去注册。

这就完成了系统服务在serviceManager上的注册了。



### 小结 

进程在启动的时候 就启动了binder，
启动binder的关键一步就是 映射内存。

也就是 进程的 内核空间和 用户空间的映射 是在进程创建的时候就完成了的。


ServiceManager负责管理注册上的binder。
Binder驱动负责 在收到客户端的binder请求的时候，建立内核空间的接收缓存，并且映射到 服务端的内核空间中。
从而实现  接收缓存 - 服务端内核空间 - 服务端用户空间的映射链。

然后binder驱动 只需要处理接收缓存和客户端的用户空间的数据拷贝即可。
不需要处理 服务端的用户空间和内科空间的数据拷贝。









## Handler的理解









## UI刷新机制













