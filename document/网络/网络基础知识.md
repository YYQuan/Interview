# 网络基础





## 网络分层架构



![image-20210726173855929](https://i.loli.net/2021/07/26/p2VjqvsQ1XLUwBC.png)





应用层： 因理解成   app , 而不是设备  负责发起网络信息和处理信息
传输层： 确保 应用层的数据能正确的被发送/ 接收  
网络层： 关心数据应该发给谁。（给下一步给哪个设备， 走哪个线路）   （ ip协议所在的层）
链接层： 理解为网线和无线信号得了
物理层：理解为网线和无线信号得了

```tips
ping： 也是在应用层， 可以说 能被用户直接使用的   都在应用层
```



QA:

连接是什么？
本质上连接就是CS 两端保存下来的状态信息。
也就说CS两端的能相互匹配的内存数据，就是连接的本质。
所以连接的本身只是消耗了 内存。
当然  要通过连接去发送数据， 那就涉及到cpu 网卡这些了。



## 握手和挥手



思考：如何确认消息收到？
首先这个确认消息收到 是传输层需要考虑的事情，然后要想确认收到  发送方就得通过消息的接收方的回复来感知。





![image-20210726180133792](https://i.loli.net/2021/07/26/z6gTnDhiHYZBKV7.png)

两方需要相互确认 对方能收到  消息 。
得经过 两次 的发送 - 应答 才行。
但是为啥 tcp握手只需要三次呢？
原因是因为 tcp协议 中允许 服务端把应答和请求合并到一起，所以只需要三条消息就可以。就类似
B的回复里就有了 我收到了 并且要问你 能不能收到 ，两重信息。

![image-20210726180524574](https://i.loli.net/2021/07/26/mXZFAsvhu5orcgO.png)



那为什么挥手要四次呢？
本质上也是需要两次 发送 -应答 的流程。
但是挥手的时候， 服务端可能还有工作要做，所以并不能 想握手的时候一样，把发送和应答合并到一起。
应答是必须马上处理，要不发送方就不知道是不是有什么异常了。

![image-20210726180927674](https://i.loli.net/2021/07/26/lB7ZDo9f1CqyrgA.png)


思考：

如何一次 发送  多个数据？（提高吞吐量）
![image-20210726181310513](https://i.loli.net/2021/07/26/b7p5D6ZgIqj4Ylf.png)

怎么判断 有数据丢失呢？要求重发呢？用什么样的窗口 效率能更高些呢？

方案1：用额外的队列来记录发送出的消息有无被应答， 等队列的数据被应答了再移除。那这种方式如果有一个消息没被应答，就得一直维护着这个队列。
tcp使用的方式： 滑动窗口。
一次发一个窗口的全部内容 ， 窗口再  按序号排列的数组中滑动， 已发送的消息就直接滑出窗口， 如果在窗口内 有未被应答的消息 ，那么就以未被发送的消息左右起始点 再发出去（消息的发送是一窗口为基本单元的。）
这样就可以一次发送多个消息 ，增加了吞吐量的。
当然在滑动窗口的模型的， 在未应答后的消息  就算已经被应答了，那也是会再被发送出去的。
滑动窗口解决： 1. 可靠性， 2，传输速率
可靠性好理解 ，传输速率怎么说。
因为窗口的大小是可变的。当发现一直都没有丢失消息， 那么就可以把窗口放大些，如果一直在丢失消息，那么就把窗口缩小，减少重发的次数。

用滑动窗口比用队列更灵活些，而且只需要维护一个大内存就行， 不需要再分要发送的消息队列， 待回复的消息队列等等这些状态机。







## IP地址

v4   v6.

![image-20210726183309692](https://i.loli.net/2021/07/26/YCRuLPnB64qZwtA.png)



## Socket

本质是个管道文件。





## Http



### HTTP报文

请求报文

![image-20201117111352423](https://i.loli.net/2020/11/17/M28PS5T6xWXHqir.png)

响应报文
![image-20201117111443160](https://i.loli.net/2020/11/17/LuXcI8oDJkUEa9K.png)



### HTTP1.1

HTTP1.1  最重要的优化就是 支持了 tcp 连接的复用

![image-20201117112259113](https://i.loli.net/2020/11/17/MgC1m6u3SDkzeJc.png)

### HTTPS

HTTPS  是为了解决 明文传输 和数据安全的 而做的优化

实际上就是HTTP1.1中加了一层处理加密的ssl层

![img](https://img.mukewang.com/wiki/5ef172620926253e06600590.jpg)

HTTPS 加解密过程

![img](https://img.mukewang.com/wiki/5ef1726c09b9e07b19241450.jpg)



描述一下：
SSL  就是服务器 维护着一套**公钥和私钥的证书**。
APP 端通过ssl去确认证书是否有效， 然后随机生成一个会话密钥。
然后APP端通过服务器给的公钥对会话密钥进行加密 传输给服务端，
服务端收到之后 用私钥解密得到会话密钥。
然后客户端和服务端之间的通讯都用 **会话密钥** 的加密进行传输。



ps: 免费的CA 证书 发布机构 letsencrypt.org

![image-20201117114547042](https://i.loli.net/2020/11/17/mOt8NiVql9FDb45.png)



HTTPS  由于增加了 加解密认证的过程， 传输速度会有影响
因此google开发spdy协议

### SPDY 

SPDY : google 开发的 应用层协议  可以理解为HTTPS协议的增强

1.用多个HTTP请求共享一个TCP通道， 来降低 HTTP的延时
2.对请求头进行压缩
3.

![image-20201117114857790](https://i.loli.net/2020/11/17/gnZJzT6NjRsawDU.png)

![img](https://img.mukewang.com/wiki/5ef172760985e9a805160708.jpg)



### HTTP2.0

HTTP2.0 借鉴了很多google的SPDY 协议的优点 比如 多路复用，  压缩请求头..
最重要的是 **重新定义了二进制格式**，不再是文本传输，而是用二进制传输。（前面的spdy ,https ,http1.1 .都是文本传输的）
二进制传输比文本传输更加健壮一些。

原本HTTP2.0会把消息分成更小单位的消息体 frame来发送
而且HTTP2.0在共享tcp连接的基础上 同时发送请求和响应，
由于HTTP2.0把分成了 frame ， 同一个消息不同的帧是可以在不同 的tcp通道上进行交错的发送，从而极大的提高了效率

![img](https://img.mukewang.com/wiki/5ef1727f097f87c220461136.jpg)



### HTTP3.0

基本没被商用。
最大的改变就是 把传输层 从tcp改成的udp,不再进行三次握手的处理。

![image-20201117142210726](https://i.loli.net/2020/11/17/fFTcJqUdPiSQn9w.png)

![img](https://img.mukewang.com/wiki/5ef172880968abd706680666.jpg)

















