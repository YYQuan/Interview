# 常用数据结构类分析



常用的有list, set, map

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150625230138672)



对于这些Collections 来分析 主要有如下维度：

- 储存的形式 : 数组/链表/树状  ?
- 容量怎么决定，怎么扩容
- CRUD （create/read/update/del）



## List

### ArrayList





#### 存储的形式

从构造函数来看 ，直接就能看到就是数组来存储的。

![image-20210723101617462](https://i.loli.net/2021/07/23/a6gKEkoiPD1GxHw.png)



#### 容量大小

先从构造函数入手

![image-20210723102315615](https://i.loli.net/2021/07/23/T2NHsGlQFvUcwIm.png)

发现有两种情况：

- 一个空数组
- 由传参决定



初始的容量看到了。
接下来看 ，在crud 过程中 容量是怎么变化的。
这里只关注容量的改变。

##### 增时（扩容）：

![image-20210723104731286](https://i.loli.net/2021/07/23/83SaT2KmXfr4bZN.png)

默认最小容量是10

![image-20210723104756678](https://i.loli.net/2021/07/23/bokFAEmrut51VNX.png)

从下面的代码中 可以看出

- 最大容量  Integer.MAX
- 每次扩容   增加当前容量的 50%

![image-20210723174905279](https://i.loli.net/2021/07/23/RDojCshica9mTnQ.png)

看代码 ，这里有个疑问

Q：为啥数组的最大长度 的常量定义成 MAX_VALUE -8呢？ 而且在size 大于 MAX_VALUE_8
的情况下，仍然允许把size 设置成大于MAX_VALUE-8呢？

注释里有解释， 原因是因为 有些虚拟机 会给数组加一个头数据，会占8个字节。

也就是
有些虚拟机 数组的最大数量是 Integer.MAX 
有些是Integer.MAX -8

![image-20210723175525218](https://i.loli.net/2021/07/23/SHVPXdN1CGk6uew.png)

##### 缩容

从下面的代码中 可以知道
remove的操作是通过 copy来完成的
并没有做缩容

直接是把要删除的元素 后面的元素 当做一个整体 复制；



对于ArrayList来说 是没有缩容的操作的。除了clear之外；

![image-20210723175930571](https://i.loli.net/2021/07/23/SuBQUxrfHF3TzWn.png)

前面看到 add和remove都是通过System.arraycopy() 来完成的。
来分析一下System.arraycopy

##### System.arraycopy

这是个native函数。
各个参数 根据注释很好理解

![image-20210723180913752](https://i.loli.net/2021/07/23/QrqauxmAzokjFUX.png)

#### CRUD

根据上面对容量的分析 基本上就已经理解了ArrayList的增删改查了。



### LinkedList

LinkedList 和ArrayList使用上的最大区别就是
LinkedList可以当做队列来使用。
![image-20210723181553620](https://i.loli.net/2021/07/23/FUg4icX2VZAEs98.png)



#### 储存的形式

一眼就看出来  就是链表  而且是一个双向链表。
其实从 LinkedList 实现了 deque接口  就是猜到 内部是一个双向链接来实现的。

![image-20210723181732126](https://i.loli.net/2021/07/23/sF9fTNiK3SxR1ml.png)

![image-20210723181922765](https://i.loli.net/2021/07/23/KqAEVQGjJbvNitO.png)





#### 容量大小

从下图 可知，  linkedList 由于是链表来实现的 本身是没有容量的限制的。
但是由于 size是int型  所以 可以认为 LinkedList的容量的大小是 Integer.MAX



![image-20210723182302698](https://i.loli.net/2021/07/23/FdAwefPYLqJ4XCE.png)

![image-20210723182215106](https://i.loli.net/2021/07/23/6A4oO2WLYNqxrzU.png)

![image-20210723182159779](https://i.loli.net/2021/07/23/EbyX8xcBMCIdmeq.png)





### ArrayList和LinkedList的对比

- 存储形式上的差别 ：   ArrayList 是数组， LinkedList是双向链表
- LinkedList 继承了双向链表的接口， 可以直接当做 队列来使用
- 两者的最大 size  可能不一样  jdk 里 给ArrayList的默认最大长度是 Integer.MAX - 8 (和虚拟机的实现有关)，linkedList是 Integer.Max ;











## Map

### HashMap

##### 储存的形式

从put函数来看储存的形式,

hashMap就是用一个数组来存储的， 但是 数组里存的是一列表。 列表可能是链表 也可能是红黑树。

从下图来看，map的存储是通过链表 或者  红黑树来存储的。
怎么看出来是 红黑树？
TreeNode那 的注释上有。 后面复习一下红黑树。

![image-20210726103911700](https://i.loli.net/2021/07/26/RinHWLYed8ZFlVP.png)



因为都是链表类型的数据， 没有严格的数量的概念，但是 HashMap 涉及到 单链表到 红黑树的转换。

##### 单链表 - > 红黑树

是什么情况下 会把单链表 转成红黑树？

![image-20210726110011127](https://i.loli.net/2021/07/26/P7zOxX9dFmIpMWQ.png)

这里看出 是和 table的最后一个元素决定的。

接下来分析下  table
table的有效赋值 是在 resize函数中。

注意 threshold 是 扩容的临界值， 不是要扩成多少。

![image-20210726113600194](https://i.loli.net/2021/07/26/ijAGUIny8Ozd2KT.png)

![image-20210726113849352](https://i.loli.net/2021/07/26/amlMP4nTOL2jgiW.png)

![image-20210726115244473](https://i.loli.net/2021/07/26/zVlRarSDfyHF7PZ.png)

![image-20210726115829743](https://i.loli.net/2021/07/26/F3bYajKZrqxkLSX.png)



从上面可以看出 ， resize函数 可以说是 HashMap的 初始化， 或者扩容处理。
先只关心初始化的情况，

![image-20210726120500643](https://i.loli.net/2021/07/26/SQ6iRTLOYsADHIP.png)


接着回到 put中

put中的resize执行完了之后 得到了 一个 长度为16的数组。
但是还是没看出 TreeNode 是怎么产生的。
接着往下看



![image-20210726121157895](https://i.loli.net/2021/07/26/lbRMvCEQ95FOtP8.png)

从这里可以看出  当链表的长度大于临界值的时候就会转成 tree ,默认的临界值是8.

这里基本就搞情况了 HashMap的存储的形式了。

总结一下就是 

初始化 一个 数组 ， 根据元素的 hash值和  当前数组的容量 功能得到 元素存储的index。
数组中存的是一个链表， 或者红黑树，  当链表的长度大于阈值的时候就会 转成红黑树来存储。
默认的阈值是 8.



put  引起的扩容  已经做了基本分析。
接下来 分析 一下  remove 

大致看了下， remove后并没有 对数组进行缩容。
原因可能是  元素之间都是散列开的， 缩容不太好处理吧。

所以说  如果map 扩容得到了一大块内存， 就算最后里面一个元素都没有，map所占的容量也不会小。



总结要点

- hashmap 是用数组来存储的 ，数组里的元素是  链表 或者 红黑树
- 链表和红黑树的转化 是根据  元素的数量来决定的 ， 默认阈值是8 ， 
- hashmap 的 存储元素在数组中 序号是根据 hash和map共同决定的 ，基本上就是 hash值  位与  容量（也就是用容量对hash截断）
- hashMap容量发生改变的时候， 元素的序号也需要改变，移动到新的index中，因为index是用容量对 hash值进行截断得到， 如果不改的话，那么 相同hash值的key 就存到不同的index 中去了。



#### ConcurrentHashMap 

[参考](https://www.cnblogs.com/hi3254014978/p/12335100.html)

HashMap 本身是非线程安全的。

非线程安全体现

- 1.7在hashmap resize 迁移数据的时候使用的是倒序插入， 在多线程的场景下， 是有可能出现链表成环的场景
- put 和resize 在多线程 中put 中已经计算了 该节点的在数组中的index后还未赋值就被抢占了，到另一个线程直接resize了。那么用之前的size算出来的index肯定就不对了。

java提供了ConcurrentHashMap来处理 线程安全问题。
concurrentHashMap的各个版本差异比较大，
1.7中是使用分段锁来优化， 思路就是让锁影响的范围更小些。

1.8中有抛弃了 分段的涉及， 主要是分段锁的段的数量是初始化的时候就根据构造函数传入的并发等级固定好的，ConCurrentHashMap的扩容，只能在segmetn的内部进行扩容。随着数据量的增加，segment的锁的操作也会越来越重。

1.8中改为了 CAS 和sychronize相互配合来完成。



疑问 ： 为啥 concurrentHashMap 不动态的增减segmetn的数量呢？
做成类似HashMap的那种数组的形式。
从put中可以看出，segmengt的位置

![image-20210729160538726](https://i.loli.net/2021/07/29/KR3tXuNUHxEgpfn.png)

segmentShift和segmentMask是初始化的时候就决定了的。

![image-20210729160757722](https://i.loli.net/2021/07/29/qzOBHa4EYXFJoyh.png)

因此 如果说 要给segment的数量进行增加的话，那么就需要把 整个Map中的所有节点都拿出来重新导入新的segments.
这个操作的时间复杂度是O(nlog^n^) 操作还是很重的。
可能是因为操作重，所以没支持segments数量的扩容。

那为什么又给1.8 中ConcurrentHashMap又给扩容了呢？
我觉得1.8 和1.7的改变的重点在于 增加了扩容的处理。
分段的思想并没有变。
以1.8的put 源码为例子分析。
是给数组中的头节点加了锁。 和分段的思想没有什么差别。
但是1.8中的数组是可以扩容的，就能够减低每一“段”的数据量，这种情况下对于1.7的实现 就有了优化。

![image-20210729162408583](https://i.loli.net/2021/07/29/oXRW8NpDPuB3iZk.png)



ConcurrentHashMap的1.7和1.8的对比
网上有点说 1.8的锁粒度更小， 但是我感觉不是。
思路上都是分段的思路。
ConcurrentHashMap 1.8优化的点其实是增加了段扩容的机制。
这个是优化的核心所在， 其他的很多只是实现上的改变和优化。



### TreeMap



#### 储存的形式

从名字就能判断是 用树来存储的。

证据：

![image-20210726142041005](https://i.loli.net/2021/07/26/perBGuT2QOwvSjt.png)

![image-20210726142120447](https://i.loli.net/2021/07/26/smp9MgCHz5thLES.png)



从上面两张图 也能看出来 是 红黑树。

感觉没啥好说的。

红黑树的分析可以看 数据结构分析。



















## Set

### HashSet

#### 储存的形式

HashSet的内部是用 HashMap来实现的。 特性和 HashMap一致

![image-20210723182726640](https://i.loli.net/2021/07/23/9a2H7cZU8YWTmKi.png)

#### 









### TreeSet

##### TreeSet 默认是TreeMap 来实现的 ， 特性和TreeMap 基本一致。



 ![image-20210726145944372](https://i.loli.net/2021/07/26/6GQAdlT4EF3MqNc.png)







